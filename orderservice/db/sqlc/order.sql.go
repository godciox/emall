// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: order.sql

package db

import (
	"context"
	"database/sql"
)

const createOrder = `-- name: CreateOrder :execresult
INSERT INTO orders (sn, amount, coupon_code_id, user_id, coupon_discount, consignee, address, phone, expire, type,
                    creation_date)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOrderParams struct {
	Sn             string       `json:"sn"`
	Amount         string       `json:"amount"`
	CouponCodeID   string       `json:"coupon_code_id"`
	UserID         int64        `json:"user_id"`
	CouponDiscount string       `json:"coupon_discount"`
	Consignee      string       `json:"consignee"`
	Address        string       `json:"address"`
	Phone          string       `json:"phone"`
	Expire         sql.NullTime `json:"expire"`
	Type           int32        `json:"type"`
	CreationDate   sql.NullTime `json:"creation_date"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOrder,
		arg.Sn,
		arg.Amount,
		arg.CouponCodeID,
		arg.UserID,
		arg.CouponDiscount,
		arg.Consignee,
		arg.Address,
		arg.Phone,
		arg.Expire,
		arg.Type,
		arg.CreationDate,
	)
}

const createOrderItem = `-- name: CreateOrderItem :execresult
INSERT INTO order_item (sn, order_id, name, price, weight, thumbnail, quantity, shipped_quantity, return_quantity,
                        sku_id, create_by, creation_date)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOrderItemParams struct {
	Sn              string         `json:"sn"`
	OrderID         int64          `json:"order_id"`
	Name            string         `json:"name"`
	Price           int32          `json:"price"`
	Weight          sql.NullInt32  `json:"weight"`
	Thumbnail       sql.NullString `json:"thumbnail"`
	Quantity        int32          `json:"quantity"`
	ShippedQuantity int32          `json:"shipped_quantity"`
	ReturnQuantity  int32          `json:"return_quantity"`
	SkuID           sql.NullInt64  `json:"sku_id"`
	CreateBy        sql.NullString `json:"create_by"`
	CreationDate    sql.NullTime   `json:"creation_date"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOrderItem,
		arg.Sn,
		arg.OrderID,
		arg.Name,
		arg.Price,
		arg.Weight,
		arg.Thumbnail,
		arg.Quantity,
		arg.ShippedQuantity,
		arg.ReturnQuantity,
		arg.SkuID,
		arg.CreateBy,
		arg.CreationDate,
	)
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
where id = ?
`

func (q *Queries) DeleteOrder(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, id)
	return err
}

const getAllOrder = `-- name: GetAllOrder :many
SELECT id,
       sn,
       amount,
       status,
       coupon_code_id,
       coupon_discount,
       consignee,
       address
FROM orders
WHERE user_id = ?
`

type GetAllOrderRow struct {
	ID             int64  `json:"id"`
	Sn             string `json:"sn"`
	Amount         string `json:"amount"`
	Status         int32  `json:"status"`
	CouponCodeID   string `json:"coupon_code_id"`
	CouponDiscount string `json:"coupon_discount"`
	Consignee      string `json:"consignee"`
	Address        string `json:"address"`
}

func (q *Queries) GetAllOrder(ctx context.Context, userID int64) ([]GetAllOrderRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrder, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllOrderRow{}
	for rows.Next() {
		var i GetAllOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.Sn,
			&i.Amount,
			&i.Status,
			&i.CouponCodeID,
			&i.CouponDiscount,
			&i.Consignee,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderAllItem = `-- name: GetOrderAllItem :many
SELECT id,
       sn,
       name,
       thumbnail,
       quantity,
       shipped_quantity,
       return_quantity,
       price
FROM order_item
WHERE order_id = ?
`

type GetOrderAllItemRow struct {
	ID              int64          `json:"id"`
	Sn              string         `json:"sn"`
	Name            string         `json:"name"`
	Thumbnail       sql.NullString `json:"thumbnail"`
	Quantity        int32          `json:"quantity"`
	ShippedQuantity int32          `json:"shipped_quantity"`
	ReturnQuantity  int32          `json:"return_quantity"`
	Price           int32          `json:"price"`
}

func (q *Queries) GetOrderAllItem(ctx context.Context, orderID int64) ([]GetOrderAllItemRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderAllItem, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderAllItemRow{}
	for rows.Next() {
		var i GetOrderAllItemRow
		if err := rows.Scan(
			&i.ID,
			&i.Sn,
			&i.Name,
			&i.Thumbnail,
			&i.Quantity,
			&i.ShippedQuantity,
			&i.ReturnQuantity,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByDate = `-- name: GetOrderByDate :many
SELECT id,
       sn,
       amount,
       status,
       coupon_code_id,
       coupon_discount,
       consignee,
       address
FROM orders
WHERE user_id = ?
  and creation_date between ? and ?
`

type GetOrderByDateParams struct {
	UserID         int64        `json:"user_id"`
	CreationDate   sql.NullTime `json:"creation_date"`
	CreationDate_2 sql.NullTime `json:"creation_date_2"`
}

type GetOrderByDateRow struct {
	ID             int64  `json:"id"`
	Sn             string `json:"sn"`
	Amount         string `json:"amount"`
	Status         int32  `json:"status"`
	CouponCodeID   string `json:"coupon_code_id"`
	CouponDiscount string `json:"coupon_discount"`
	Consignee      string `json:"consignee"`
	Address        string `json:"address"`
}

func (q *Queries) GetOrderByDate(ctx context.Context, arg GetOrderByDateParams) ([]GetOrderByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderByDate, arg.UserID, arg.CreationDate, arg.CreationDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderByDateRow{}
	for rows.Next() {
		var i GetOrderByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Sn,
			&i.Amount,
			&i.Status,
			&i.CouponCodeID,
			&i.CouponDiscount,
			&i.Consignee,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByStatus = `-- name: GetOrderByStatus :many
SELECT id,
       sn,
       amount,
       status,
       coupon_code_id,
       coupon_discount,
       consignee,
       address
FROM orders
WHERE user_id = ?
  and status = ?
`

type GetOrderByStatusParams struct {
	UserID int64 `json:"user_id"`
	Status int32 `json:"status"`
}

type GetOrderByStatusRow struct {
	ID             int64  `json:"id"`
	Sn             string `json:"sn"`
	Amount         string `json:"amount"`
	Status         int32  `json:"status"`
	CouponCodeID   string `json:"coupon_code_id"`
	CouponDiscount string `json:"coupon_discount"`
	Consignee      string `json:"consignee"`
	Address        string `json:"address"`
}

func (q *Queries) GetOrderByStatus(ctx context.Context, arg GetOrderByStatusParams) ([]GetOrderByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderByStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderByStatusRow{}
	for rows.Next() {
		var i GetOrderByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Sn,
			&i.Amount,
			&i.Status,
			&i.CouponCodeID,
			&i.CouponDiscount,
			&i.Consignee,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET status = ?
where sn = ?
`

type UpdateOrderStatusParams struct {
	Status int32  `json:"status"`
	Sn     string `json:"sn"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderStatus, arg.Status, arg.Sn)
	return err
}
